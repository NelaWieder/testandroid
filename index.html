<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <meta name="theme-color" content="#0b1020" />
    <title>Text-to-Speech Test</title>
    <style>
      :root {
        color-scheme: dark;
        --bg: #0b1020;
        --card: rgba(255, 255, 255, 0.06);
        --card-border: rgba(255, 255, 255, 0.12);
        --text: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.70);
        --ok: #22c55e;
        --bad: #ef4444;
        --warn: #f59e0b;
        --btn: #6d28d9;
        --btn2: #111827;
        --shadow: 0 16px 48px rgba(0, 0, 0, 0.45);
        --radius: 18px;
      }

      * { box-sizing: border-box; }
      html, body { height: 100%; }
      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        background:
          radial-gradient(1200px 700px at 20% 15%, rgba(109, 40, 217, 0.35), transparent 55%),
          radial-gradient(900px 700px at 85% 25%, rgba(34, 197, 94, 0.18), transparent 55%),
          radial-gradient(900px 700px at 50% 110%, rgba(59, 130, 246, 0.18), transparent 55%),
          var(--bg);
        color: var(--text);
        display: grid;
        place-items: center;
        padding: max(16px, env(safe-area-inset-top)) max(16px, env(safe-area-inset-right))
          max(16px, env(safe-area-inset-bottom)) max(16px, env(safe-area-inset-left));
      }

      .wrap {
        width: min(720px, 100%);
      }

      .card {
        background: var(--card);
        border: 1px solid var(--card-border);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        overflow: hidden;
      }

      header {
        padding: 18px 18px 12px 18px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.10);
      }
      h1 {
        font-size: 20px;
        margin: 0 0 6px 0;
        letter-spacing: 0.2px;
      }
      p {
        margin: 0;
        color: var(--muted);
        line-height: 1.35;
        font-size: 13.5px;
      }

      main { padding: 18px; }

      .row {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
      }

      .btnRow {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      @media (min-width: 520px) {
        .btnRow { grid-template-columns: 1fr 1fr; }
      }

      button {
        appearance: none;
        border: 1px solid rgba(255, 255, 255, 0.14);
        border-radius: 14px;
        padding: 14px 14px;
        font-size: 16px;
        font-weight: 650;
        color: white;
        cursor: pointer;
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.30);
        transition: transform 0.05s ease, filter 0.15s ease, border-color 0.15s ease;
        touch-action: manipulation;
      }
      button:active { transform: translateY(1px); }
      button[disabled] { opacity: 0.55; cursor: not-allowed; box-shadow: none; }

      .primary {
        background: linear-gradient(135deg, rgba(109, 40, 217, 1), rgba(59, 130, 246, 1));
        border-color: rgba(255, 255, 255, 0.16);
      }
      .secondary {
        background: rgba(17, 24, 39, 0.75);
      }

      .status {
        border-radius: 14px;
        padding: 12px 12px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(0, 0, 0, 0.18);
      }

      .statusTop {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
      }

      .pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        border-radius: 999px;
        padding: 6px 10px;
        font-size: 12px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(255, 255, 255, 0.06);
        color: var(--muted);
      }

      .dot {
        width: 9px;
        height: 9px;
        border-radius: 999px;
        background: var(--warn);
        box-shadow: 0 0 0 4px rgba(245, 158, 11, 0.16);
      }
      .dot.ok {
        background: var(--ok);
        box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.16);
      }
      .dot.bad {
        background: var(--bad);
        box-shadow: 0 0 0 4px rgba(239, 68, 68, 0.16);
      }

      .statusText {
        font-size: 14px;
        line-height: 1.35;
        margin-top: 10px;
        color: rgba(255, 255, 255, 0.88);
      }

      details {
        border-radius: 14px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(0, 0, 0, 0.12);
        padding: 10px 12px;
      }
      summary { cursor: pointer; color: var(--muted); font-weight: 600; }
      pre {
        margin: 10px 0 0 0;
        padding: 10px;
        border-radius: 12px;
        background: rgba(0, 0, 0, 0.20);
        border: 1px solid rgba(255, 255, 255, 0.12);
        overflow: auto;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.86);
        white-space: pre-wrap;
        word-break: break-word;
      }

      textarea {
        width: 100%;
        min-height: 180px;
        resize: vertical;
        margin-top: 10px;
        padding: 10px;
        border-radius: 12px;
        background: rgba(0, 0, 0, 0.20);
        border: 1px solid rgba(255, 255, 255, 0.12);
        color: rgba(255, 255, 255, 0.90);
        font-size: 12px;
        line-height: 1.35;
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      }

      .miniBtnRow {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
        margin-top: 10px;
      }
      @media (min-width: 520px) {
        .miniBtnRow { grid-template-columns: 1fr 1fr; }
      }
      .mini {
        padding: 10px 12px;
        font-size: 14px;
        border-radius: 12px;
      }

      footer {
        padding: 14px 18px 18px 18px;
        border-top: 1px solid rgba(255, 255, 255, 0.10);
        color: var(--muted);
        font-size: 12.5px;
        line-height: 1.35;
      }
      .tips {
        margin: 0;
        padding-left: 16px;
      }
      .tips li { margin: 6px 0; }
      code {
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
        font-size: 0.95em;
        color: rgba(255, 255, 255, 0.92);
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="card">
        <header>
          <h1>Text-to-Speech Test</h1>
          <p>
            This page tests the Web Speech API by speaking <strong>"Przemek gra"</strong> in Polish
            <strong>only after a user click</strong>. It uses the browser's built-in speech synthesis.
          </p>
        </header>

        <main>
          <div class="row">
            <div class="btnRow">
              <button class="primary" id="playBtn" type="button">Przeczytaj "Przemek gra"</button>
              <button class="secondary" id="resetBtn" type="button">Reset / Wyczyść status</button>
            </div>

            <div class="status" role="status" aria-live="polite" aria-atomic="true">
              <div class="statusTop">
                <span class="pill"><span class="dot" id="dot"></span><span id="statusLabel">Gotowe</span></span>
                <span class="pill" id="ctxPill">SpeechSynthesis: <code id="ctxState">sprawdzanie...</code></span>
                <span class="pill">Język: <code id="mode">pl-PL</code></span>
              </div>
              <div class="statusText" id="statusText">
                Kliknij przycisk, aby usłyszeć <strong>"Przemek gra"</strong>. Jeśli nic nie słyszysz,
                sprawdź głośność, tryb cichy i połączenie Bluetooth.
              </div>
            </div>

            <details>
              <summary>Szczegóły debugowania</summary>
              <pre id="log"></pre>
              <div class="miniBtnRow">
                <button class="secondary mini" id="reportBtn" type="button">Wygeneruj raport debug</button>
                <button class="secondary mini" id="copyBtn" type="button">Kopiuj raport</button>
              </div>
              <textarea id="report" readonly spellcheck="false"></textarea>
              <p style="margin-top:10px; color: var(--muted); font-size: 12.5px;">
                Skopiuj raport i wklej mi w czacie. Zawiera informacje o przeglądarce, głosach TTS, stanie
                <code>speechSynthesis</code> oraz ostatnich błędach/zdarzeniach.
              </p>
            </details>
          </div>
        </main>

        <footer>
          <ul class="tips">
            <li><strong>Wskazówka dla Androida</strong>: niektóre urządzenia wymagają pierwszego kliknięcia, aby „odblokować” audio. Jeśli pierwsze kliknięcie nie działa, kliknij ponownie.</li>
            <li><strong>GitHub Pages</strong>: działa przez HTTPS, bez zewnętrznych plików.</li>
            <li><strong>Zasada</strong>: brak autoodtwarzania—mowa jest uruchamiana tylko po kliknięciu przycisku.</li>
          </ul>
        </footer>
      </div>
    </div>

    <script>
      (() => {
        /** @type {HTMLButtonElement} */
        const playBtn = document.getElementById("playBtn");
        /** @type {HTMLButtonElement} */
        const resetBtn = document.getElementById("resetBtn");
        const dot = document.getElementById("dot");
        const statusLabel = document.getElementById("statusLabel");
        const statusText = document.getElementById("statusText");
        const ctxStateEl = document.getElementById("ctxState");
        const modeEl = document.getElementById("mode");
        const logEl = document.getElementById("log");
        /** @type {HTMLButtonElement} */
        const reportBtn = document.getElementById("reportBtn");
        /** @type {HTMLButtonElement} */
        const copyBtn = document.getElementById("copyBtn");
        /** @type {HTMLTextAreaElement} */
        const reportEl = document.getElementById("report");

        const SPEECH_TEXT = "Przemek gra";
        const SPEECH_LANG = "pl-PL";
        let lastPlayAt = 0;
        let currentUtterance = null;
        /** @type {{at: string, type: string, data?: any}[]} */
        const ttsEvents = [];
        let lastTtsError = null;
        /** @type {string[]} */
        const logLines = [];

        function nowISO() {
          return new Date().toISOString().replace("T", " ").replace("Z", "Z");
        }

        function log(line) {
          const prefix = `[${nowISO()}] `;
          const full = prefix + line;
          logLines.push(full);
          if (logLines.length > 400) logLines.splice(0, logLines.length - 400);
          logEl.textContent = logLines.join("\n");
        }

        function pushTtsEvent(type, data) {
          const ev = { at: nowISO(), type, data };
          ttsEvents.push(ev);
          if (ttsEvents.length > 120) ttsEvents.splice(0, ttsEvents.length - 120);
        }

        function setStatus(kind, title, message) {
          // kind: "ready" | "ok" | "bad" | "warn"
          statusLabel.textContent = title;
          statusText.textContent = message;
          dot.classList.remove("ok", "bad");
          if (kind === "ok") dot.classList.add("ok");
          else if (kind === "bad") dot.classList.add("bad");
          // warn/ready keep default amber dot
        }

        function updateSpeechState() {
          const synth = window.speechSynthesis;
          if (!synth) {
            ctxStateEl.textContent = "nieobsługiwane";
            return;
          }
          const pending = synth.pending;
          const speaking = synth.speaking;
          let state = "dostępne";
          if (speaking) state = "mówi...";
          else if (pending) state = "oczekuje...";
          ctxStateEl.textContent = state;
        }

        function safeGetVoices() {
          try {
            if (!window.speechSynthesis) return [];
            return window.speechSynthesis.getVoices() || [];
          } catch (e) {
            return [];
          }
        }

        function voicesSummary(voices) {
          return voices.map(v => ({
            name: v.name,
            lang: v.lang,
            localService: v.localService,
            default: v.default,
            voiceURI: v.voiceURI
          }));
        }

        function buildReport() {
          const synth = window.speechSynthesis || null;
          const voices = safeGetVoices();
          const polishVoices = voices.filter(v => (v.lang || "").toLowerCase().startsWith("pl"));

          return {
            generatedAt: nowISO(),
            page: {
              href: location.href,
              origin: location.origin,
              protocol: location.protocol,
              https: location.protocol === "https:",
            },
            device: {
              userAgent: navigator.userAgent,
              platform: navigator.platform || null,
              language: navigator.language || null,
              languages: navigator.languages || null,
            },
            webSpeechApi: {
              supported: !!window.speechSynthesis,
              utteranceSupported: typeof SpeechSynthesisUtterance !== "undefined",
              onvoiceschangedSupported: !!(synth && "onvoiceschanged" in synth),
            },
            speechSynthesisState: synth
              ? {
                  speaking: !!synth.speaking,
                  pending: !!synth.pending,
                  paused: !!synth.paused,
                }
              : null,
            voices: {
              total: voices.length,
              polishCount: polishVoices.length,
              list: voicesSummary(voices),
            },
            lastUtterance: currentUtterance
              ? {
                  text: currentUtterance.text,
                  lang: currentUtterance.lang,
                  rate: currentUtterance.rate,
                  pitch: currentUtterance.pitch,
                  volume: currentUtterance.volume,
                  voice: currentUtterance.voice
                    ? {
                        name: currentUtterance.voice.name,
                        lang: currentUtterance.voice.lang,
                        localService: currentUtterance.voice.localService,
                        default: currentUtterance.voice.default,
                        voiceURI: currentUtterance.voice.voiceURI,
                      }
                    : null,
                }
              : null,
            lastTtsError,
            ttsEvents,
            recentLog: logLines.slice(-120),
          };
        }

        function updateReport() {
          try {
            const report = buildReport();
            reportEl.value = JSON.stringify(report, null, 2);
          } catch (e) {
            reportEl.value = `Nie udało się zbudować raportu: ${e && e.message ? e.message : String(e)}`;
          }
        }

        function checkSpeechSupport() {
          if (!window.speechSynthesis) {
            return { supported: false, error: "Web Speech API (speechSynthesis) nie jest obsługiwane w tej przeglądarce." };
          }
          return { supported: true };
        }

        function speakText(text, lang) {
          return new Promise((resolve, reject) => {
            const synth = window.speechSynthesis;
            
            // Cancel any ongoing speech
            synth.cancel();
            
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = lang;
            utterance.rate = 1.0;
            utterance.pitch = 1.0;
            utterance.volume = 1.0;

            // Try to pick a matching voice: Polish first, then fallback to any available voice
            const voices = safeGetVoices();
            let preferred =
              voices.find(v => (v.lang || "").toLowerCase() === lang.toLowerCase()) ||
              voices.find(v => (v.lang || "").toLowerCase().startsWith("pl"));
            
            // Fallback: jeśli brak polskiego, użyj pierwszego dostępnego głosu
            if (!preferred && voices.length > 0) {
              preferred = voices[0];
              log(`Uwaga: brak głosu polskiego, używam fallback: ${preferred.name} (${preferred.lang})`);
            }
            
            if (preferred) {
              utterance.voice = preferred;
              utterance.lang = preferred.lang; // Ustaw język zgodny z głosem
            }
            
            let startTimeout = null;
            let endTimeout = null;
            let startFired = false;
            let endFired = false;
            
            const cleanup = () => {
              if (startTimeout) clearTimeout(startTimeout);
              if (endTimeout) clearTimeout(endTimeout);
            };
            
            utterance.onstart = () => {
              startFired = true;
              if (startTimeout) clearTimeout(startTimeout);
              log(`Rozpoczęto mówienie: "${text}"`);
              pushTtsEvent("start", { text, lang: utterance.lang, voice: utterance.voice ? { name: utterance.voice.name, lang: utterance.voice.lang } : null });
              updateSpeechState();
              updateReport();
            };
            
            utterance.onend = () => {
              endFired = true;
              cleanup();
              log(`Zakończono mówienie.`);
              pushTtsEvent("end");
              currentUtterance = null;
              updateSpeechState();
              updateReport();
              resolve();
            };
            
            utterance.onerror = (event) => {
              cleanup();
              const errMsg = event && event.error ? `Błąd: ${event.error}` : "Nieznany błąd podczas mówienia.";
              log(`Błąd TTS: ${errMsg}`);
              lastTtsError = { at: nowISO(), message: errMsg, raw: event ? { error: event.error, elapsedTime: event.elapsedTime, name: event.name } : null };
              pushTtsEvent("error", lastTtsError);
              currentUtterance = null;
              updateSpeechState();
              updateReport();
              reject(new Error(errMsg));
            };
            
            currentUtterance = utterance;
            pushTtsEvent("speak_called", { text, lang: utterance.lang, hasVoice: !!utterance.voice, voiceName: utterance.voice ? utterance.voice.name : null, voicesNow: voices.length });
            
            // Timeout dla onstart - Android Chrome czasami nie wywołuje tego eventu
            startTimeout = setTimeout(() => {
              if (!startFired) {
                log(`UWAGA: onstart nie został wywołany po 2 sekundach, ale speaking=${synth.speaking}`);
                pushTtsEvent("start_timeout", { speaking: synth.speaking, pending: synth.pending });
                // Jeśli speaking jest true, prawdopodobnie działa, ale bez eventu
                if (synth.speaking) {
                  startFired = true; // Symuluj start
                  log(`Mówienie wydaje się działać (speaking=true), kontynuuję...`);
                }
              }
            }, 2000);
            
            // Timeout dla onend - jeśli nie wywoła się w 10 sekundach, uznać za problem
            endTimeout = setTimeout(() => {
              if (!endFired) {
                log(`UWAGA: onend nie został wywołany po 10 sekundach. speaking=${synth.speaking}, pending=${synth.pending}`);
                pushTtsEvent("end_timeout", { speaking: synth.speaking, pending: synth.pending });
                if (!synth.speaking && !synth.pending) {
                  // Wydaje się, że się skończyło, ale bez eventu
                  endFired = true;
                  cleanup();
                  log(`Mówienie wydaje się zakończone (speaking=false, pending=false), kończę...`);
                  currentUtterance = null;
                  updateSpeechState();
                  updateReport();
                  resolve();
                } else {
                  // Nadal mówi lub czeka - może być problem
                  log(`Mówienie nadal trwa lub czeka. Anuluję i zgłaszam błąd.`);
                  synth.cancel();
                  cleanup();
                  currentUtterance = null;
                  updateSpeechState();
                  updateReport();
                  reject(new Error("Timeout: onend nie został wywołany i mówienie nie zakończyło się w oczekiwanym czasie."));
                }
              }
            }, 10000);
            
            synth.speak(utterance);
            updateSpeechState();
            updateReport();
          });
        }

        async function playBeepWebAudio() {
          return new Promise((resolve, reject) => {
            try {
              const Ctx = window.AudioContext || window.webkitAudioContext;
              if (!Ctx) {
                reject(new Error("Web Audio API nie jest obsługiwane."));
                return;
              }
              const ctx = new Ctx({ latencyHint: "interactive" });
              const t0 = ctx.currentTime;
              const duration = 0.3;
              const osc = ctx.createOscillator();
              const gain = ctx.createGain();

              osc.type = "sine";
              osc.frequency.setValueAtTime(440, t0);

              gain.gain.setValueAtTime(0.0001, t0);
              gain.gain.exponentialRampToValueAtTime(0.15, t0 + 0.02);
              gain.gain.exponentialRampToValueAtTime(0.0001, t0 + duration);

              osc.connect(gain);
              gain.connect(ctx.destination);

              osc.start(t0);
              osc.stop(t0 + duration + 0.02);
              osc.onended = () => {
                try { osc.disconnect(); } catch (_) {}
                try { gain.disconnect(); } catch (_) {}
                ctx.close().catch(() => {});
                resolve();
              };
            } catch (e) {
              reject(e);
            }
          });
        }

        async function onPlayClick() {
          const t = Date.now();
          lastPlayAt = t;
          playBtn.disabled = true;
          setStatus("warn", "Rozpoczynanie…", `Próba odczytania "${SPEECH_TEXT}". Jeśli pierwsze kliknięcie nie działa, kliknij ponownie.`);
          log(`Użytkownik kliknął przycisk odtwarzania.`);

          const support = checkSpeechSupport();
          if (!support.supported) {
            setStatus("bad", "Błąd", support.error || "Web Speech API nie jest obsługiwane.");
            log(`Brak wsparcia: ${support.error}`);
            return;
          }

          try {
            const voices = safeGetVoices();
            const polishVoices = voices.filter(v => (v.lang || "").toLowerCase().startsWith("pl"));
            const willUseVoice = voices.find(v => (v.lang || "").toLowerCase() === SPEECH_LANG.toLowerCase()) ||
                                 voices.find(v => (v.lang || "").toLowerCase().startsWith("pl")) ||
                                 (voices.length > 0 ? voices[0] : null);
            
            if (willUseVoice) {
              modeEl.textContent = willUseVoice.lang;
              log(`Używanie Web Speech API. Tekst: "${SPEECH_TEXT}", język: ${SPEECH_LANG}, głos: ${willUseVoice.name} (${willUseVoice.lang})`);
            } else {
              modeEl.textContent = SPEECH_LANG + " (domyślny)";
              log(`Używanie Web Speech API. Tekst: "${SPEECH_TEXT}", język: ${SPEECH_LANG} (brak głosów, użyję domyślnego)`);
            }
            
            await speakText(SPEECH_TEXT, SPEECH_LANG);
            setStatus("ok", "Sukces", `Odczytano "${SPEECH_TEXT}". Jeśli nic nie słyszysz, sprawdź głośność i tryb cichy.`);
            log(`Mówienie zakończone pomyślnie.`);
          } catch (err) {
            const msg = err && typeof err === "object" && "message" in err ? String(err.message) : String(err);
            log(`Błąd TTS: ${msg}. Próbuję fallback Web Audio...`);
            
            // Fallback: Web Audio beep
            try {
              modeEl.textContent = "Web Audio (fallback)";
              await playBeepWebAudio();
              setStatus("warn", "Fallback", `TTS nie zadziałał, ale Web Audio działa. Sprawdź czy głosy TTS są dostępne w ustawieniach systemowych.`);
              log(`Fallback Web Audio zakończony pomyślnie.`);
            } catch (audioErr) {
              const audioMsg = audioErr && typeof audioErr === "object" && "message" in audioErr ? String(audioErr.message) : String(audioErr);
              setStatus(
                "bad",
                "Błąd",
                `Nie udało się odczytać tekstu ani odtworzyć dźwięku. Zobacz szczegóły debugowania. Spróbuj: zwiększ głośność, wyłącz Bluetooth i kliknij ponownie.`
              );
              log(`Fallback Web Audio również nie zadziałał: ${audioMsg}`);
            }
          }
        }

        function onResetClick() {
          // Cancel any ongoing speech
          if (window.speechSynthesis) {
            window.speechSynthesis.cancel();
          }
          currentUtterance = null;
          lastTtsError = null;
          ttsEvents.length = 0;
          logEl.textContent = "";
          logLines.length = 0;
          modeEl.textContent = SPEECH_LANG;
          setStatus(
            "ready",
            "Gotowe",
            `Kliknij przycisk, aby usłyszeć "${SPEECH_TEXT}". Jeśli nic nie słyszysz, sprawdź głośność, tryb cichy i połączenie Bluetooth.`
          );
          log("Reset kliknięty; status wyczyszczony.");
          updateSpeechState();
          updateReport();
        }

        // Initial info
        log(`User agent: ${navigator.userAgent}`);
        log(`HTTPS: ${location.protocol === "https:" ? "tak" : "nie"}; origin=${location.origin}`);
        
        const support = checkSpeechSupport();
        if (support.supported) {
          log(`Web Speech API jest obsługiwane.`);
          const synth = window.speechSynthesis;
          const voices = synth.getVoices();
          log(`Dostępne głosy: ${voices.length}`);
          const polishVoices = voices.filter(v => v.lang.startsWith("pl"));
          if (polishVoices.length > 0) {
            log(`Głosy polskie: ${polishVoices.map(v => `${v.name} (${v.lang})`).join(", ")}`);
          } else {
            log(`Uwaga: nie znaleziono głosów polskich. Używany będzie domyślny głos.`);
          }
        } else {
          log(`Błąd: ${support.error}`);
        }
        
        updateSpeechState();
        setStatus("ready", "Gotowe", `Kliknij przycisk, aby usłyszeć "${SPEECH_TEXT}".`);
        updateReport();
        
        // Some browsers load voices asynchronously
        if (window.speechSynthesis && window.speechSynthesis.onvoiceschanged !== undefined) {
          window.speechSynthesis.onvoiceschanged = () => {
            const voices = window.speechSynthesis.getVoices();
            const polishVoices = voices.filter(v => v.lang.startsWith("pl"));
            if (polishVoices.length > 0) {
              log(`Głosy załadowane: ${polishVoices.map(v => `${v.name} (${v.lang})`).join(", ")}`);
            }
            pushTtsEvent("voiceschanged", { total: voices.length, polish: polishVoices.length });
            updateReport();
          };
        }

        reportBtn.addEventListener("click", () => {
          log("Wygenerowano raport debug (ręcznie).");
          pushTtsEvent("report_generated");
          updateSpeechState();
          updateReport();
          try { reportEl.focus(); } catch (_) {}
        }, { passive: true });

        copyBtn.addEventListener("click", async () => {
          updateReport();
          const text = reportEl.value || "";
          try {
            if (navigator.clipboard && navigator.clipboard.writeText) {
              await navigator.clipboard.writeText(text);
              log("Raport skopiowany do schowka (Clipboard API).");
            } else {
              reportEl.focus();
              reportEl.select();
              const ok = document.execCommand("copy");
              log(ok ? "Raport skopiowany do schowka (execCommand)." : "Nie udało się skopiować (execCommand=false). Skopiuj ręcznie.");
            }
            setStatus("ok", "Skopiowano", "Raport debug został skopiowany do schowka. Wklej go tutaj w czacie.");
          } catch (e) {
            log(`Kopiowanie nie powiodło się: ${e && e.message ? e.message : String(e)}`);
            setStatus("warn", "Nie skopiowano", "Nie udało się skopiować automatycznie. Skopiuj tekst z pola raportu ręcznie.");
          } finally {
            updateReport();
          }
        }, { passive: true });

        playBtn.addEventListener("click", async () => {
          // Enforce "only after interaction": everything audio-related happens inside this handler.
          const start = Date.now();
          try {
            await onPlayClick();
          } finally {
            // If user clicks repeatedly, re-enable quickly but avoid double-press spam.
            const elapsed = Date.now() - start;
            const minDisableMs = 450;
            const wait = Math.max(0, minDisableMs - elapsed);
            setTimeout(() => {
              if (lastPlayAt === start) playBtn.disabled = false;
            }, wait);
            updateSpeechState();
            updateReport();
          }
        }, { passive: true });

        resetBtn.addEventListener("click", onResetClick, { passive: true });
      })();
    </script>
  </body>
</html>
