<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <meta name="theme-color" content="#0b1020" />
    <title>Text-to-Speech Test</title>
    <style>
      :root {
        color-scheme: dark;
        --bg: #0b1020;
        --card: rgba(255, 255, 255, 0.06);
        --card-border: rgba(255, 255, 255, 0.12);
        --text: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.70);
        --ok: #22c55e;
        --bad: #ef4444;
        --warn: #f59e0b;
        --btn: #6d28d9;
        --btn2: #111827;
        --shadow: 0 16px 48px rgba(0, 0, 0, 0.45);
        --radius: 18px;
      }

      * { box-sizing: border-box; }
      html, body { height: 100%; }
      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        background:
          radial-gradient(1200px 700px at 20% 15%, rgba(109, 40, 217, 0.35), transparent 55%),
          radial-gradient(900px 700px at 85% 25%, rgba(34, 197, 94, 0.18), transparent 55%),
          radial-gradient(900px 700px at 50% 110%, rgba(59, 130, 246, 0.18), transparent 55%),
          var(--bg);
        color: var(--text);
        display: grid;
        place-items: center;
        padding: max(16px, env(safe-area-inset-top)) max(16px, env(safe-area-inset-right))
          max(16px, env(safe-area-inset-bottom)) max(16px, env(safe-area-inset-left));
      }

      .wrap {
        width: min(720px, 100%);
      }

      .card {
        background: var(--card);
        border: 1px solid var(--card-border);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        overflow: hidden;
      }

      header {
        padding: 18px 18px 12px 18px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.10);
      }
      h1 {
        font-size: 20px;
        margin: 0 0 6px 0;
        letter-spacing: 0.2px;
      }
      p {
        margin: 0;
        color: var(--muted);
        line-height: 1.35;
        font-size: 13.5px;
      }

      main { padding: 18px; }

      .row {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
      }

      .btnRow {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      @media (min-width: 520px) {
        .btnRow { grid-template-columns: 1fr 1fr; }
      }

      button {
        appearance: none;
        border: 1px solid rgba(255, 255, 255, 0.14);
        border-radius: 14px;
        padding: 14px 14px;
        font-size: 16px;
        font-weight: 650;
        color: white;
        cursor: pointer;
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.30);
        transition: transform 0.05s ease, filter 0.15s ease, border-color 0.15s ease;
        touch-action: manipulation;
      }
      button:active { transform: translateY(1px); }
      button[disabled] { opacity: 0.55; cursor: not-allowed; box-shadow: none; }

      .primary {
        background: linear-gradient(135deg, rgba(109, 40, 217, 1), rgba(59, 130, 246, 1));
        border-color: rgba(255, 255, 255, 0.16);
      }
      .secondary {
        background: rgba(17, 24, 39, 0.75);
      }

      .status {
        border-radius: 14px;
        padding: 12px 12px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(0, 0, 0, 0.18);
      }

      .statusTop {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
      }

      .pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        border-radius: 999px;
        padding: 6px 10px;
        font-size: 12px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(255, 255, 255, 0.06);
        color: var(--muted);
      }

      .dot {
        width: 9px;
        height: 9px;
        border-radius: 999px;
        background: var(--warn);
        box-shadow: 0 0 0 4px rgba(245, 158, 11, 0.16);
      }
      .dot.ok {
        background: var(--ok);
        box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.16);
      }
      .dot.bad {
        background: var(--bad);
        box-shadow: 0 0 0 4px rgba(239, 68, 68, 0.16);
      }

      .statusText {
        font-size: 14px;
        line-height: 1.35;
        margin-top: 10px;
        color: rgba(255, 255, 255, 0.88);
      }

      details {
        border-radius: 14px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(0, 0, 0, 0.12);
        padding: 10px 12px;
      }
      summary { cursor: pointer; color: var(--muted); font-weight: 600; }
      pre {
        margin: 10px 0 0 0;
        padding: 10px;
        border-radius: 12px;
        background: rgba(0, 0, 0, 0.20);
        border: 1px solid rgba(255, 255, 255, 0.12);
        overflow: auto;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.86);
        white-space: pre-wrap;
        word-break: break-word;
      }

      footer {
        padding: 14px 18px 18px 18px;
        border-top: 1px solid rgba(255, 255, 255, 0.10);
        color: var(--muted);
        font-size: 12.5px;
        line-height: 1.35;
      }
      .tips {
        margin: 0;
        padding-left: 16px;
      }
      .tips li { margin: 6px 0; }
      code {
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
        font-size: 0.95em;
        color: rgba(255, 255, 255, 0.92);
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="card">
        <header>
          <h1>Text-to-Speech Test</h1>
          <p>
            This page tests the Web Speech API by speaking <strong>"Przemek gra"</strong> in Polish
            <strong>only after a user click</strong>. It uses the browser's built-in speech synthesis.
          </p>
        </header>

        <main>
          <div class="row">
            <div class="btnRow">
              <button class="primary" id="playBtn" type="button">Przeczytaj "Przemek gra"</button>
              <button class="secondary" id="resetBtn" type="button">Reset / Wyczyść status</button>
            </div>

            <div class="status" role="status" aria-live="polite" aria-atomic="true">
              <div class="statusTop">
                <span class="pill"><span class="dot" id="dot"></span><span id="statusLabel">Gotowe</span></span>
                <span class="pill" id="ctxPill">SpeechSynthesis: <code id="ctxState">sprawdzanie...</code></span>
                <span class="pill">Język: <code id="mode">pl-PL</code></span>
              </div>
              <div class="statusText" id="statusText">
                Kliknij przycisk, aby usłyszeć <strong>"Przemek gra"</strong>. Jeśli nic nie słyszysz,
                sprawdź głośność, tryb cichy i połączenie Bluetooth.
              </div>
            </div>

            <details>
              <summary>Szczegóły debugowania</summary>
              <pre id="log"></pre>
            </details>
          </div>
        </main>

        <footer>
          <ul class="tips">
            <li><strong>Wskazówka dla Androida</strong>: some devices require the first tap to “unlock” audio. If the first tap fails, tap again.</li>
            <li><strong>GitHub Pages</strong>: działa przez HTTPS, bez zewnętrznych plików.</li>
            <li><strong>Zasada</strong>: brak autoodtwarzania—mowa jest uruchamiana tylko po kliknięciu przycisku.</li>
          </ul>
        </footer>
      </div>
    </div>

    <script>
      (() => {
        /** @type {HTMLButtonElement} */
        const playBtn = document.getElementById("playBtn");
        /** @type {HTMLButtonElement} */
        const resetBtn = document.getElementById("resetBtn");
        const dot = document.getElementById("dot");
        const statusLabel = document.getElementById("statusLabel");
        const statusText = document.getElementById("statusText");
        const ctxStateEl = document.getElementById("ctxState");
        const modeEl = document.getElementById("mode");
        const logEl = document.getElementById("log");

        const SPEECH_TEXT = "Przemek gra";
        const SPEECH_LANG = "pl-PL";
        let lastPlayAt = 0;
        let currentUtterance = null;

        function nowISO() {
          return new Date().toISOString().replace("T", " ").replace("Z", "Z");
        }

        function log(line) {
          const prefix = `[${nowISO()}] `;
          logEl.textContent = (logEl.textContent ? logEl.textContent + "\n" : "") + prefix + line;
        }

        function setStatus(kind, title, message) {
          // kind: "ready" | "ok" | "bad" | "warn"
          statusLabel.textContent = title;
          statusText.textContent = message;
          dot.classList.remove("ok", "bad");
          if (kind === "ok") dot.classList.add("ok");
          else if (kind === "bad") dot.classList.add("bad");
          // warn/ready keep default amber dot
        }

        function updateSpeechState() {
          const synth = window.speechSynthesis;
          if (!synth) {
            ctxStateEl.textContent = "nieobsługiwane";
            return;
          }
          const pending = synth.pending;
          const speaking = synth.speaking;
          let state = "dostępne";
          if (speaking) state = "mówi...";
          else if (pending) state = "oczekuje...";
          ctxStateEl.textContent = state;
        }

        function checkSpeechSupport() {
          if (!window.speechSynthesis) {
            return { supported: false, error: "Web Speech API (speechSynthesis) nie jest obsługiwane w tej przeglądarce." };
          }
          return { supported: true };
        }

        function speakText(text, lang) {
          return new Promise((resolve, reject) => {
            const synth = window.speechSynthesis;
            
            // Cancel any ongoing speech
            synth.cancel();
            
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = lang;
            utterance.rate = 1.0;
            utterance.pitch = 1.0;
            utterance.volume = 1.0;
            
            utterance.onstart = () => {
              log(`Rozpoczęto mówienie: "${text}"`);
              updateSpeechState();
            };
            
            utterance.onend = () => {
              log(`Zakończono mówienie.`);
              currentUtterance = null;
              updateSpeechState();
              resolve();
            };
            
            utterance.onerror = (event) => {
              const errMsg = event.error ? `Błąd: ${event.error}` : "Nieznany błąd podczas mówienia.";
              log(`Błąd TTS: ${errMsg}`);
              currentUtterance = null;
              updateSpeechState();
              reject(new Error(errMsg));
            };
            
            currentUtterance = utterance;
            synth.speak(utterance);
            updateSpeechState();
          });
        }

        async function onPlayClick() {
          const t = Date.now();
          lastPlayAt = t;
          playBtn.disabled = true;
          setStatus("warn", "Rozpoczynanie…", `Próba odczytania "${SPEECH_TEXT}". Jeśli pierwsze kliknięcie nie działa, kliknij ponownie.`);
          log(`Użytkownik kliknął przycisk odtwarzania.`);

          const support = checkSpeechSupport();
          if (!support.supported) {
            setStatus("bad", "Błąd", support.error || "Web Speech API nie jest obsługiwane.");
            log(`Brak wsparcia: ${support.error}`);
            return;
          }

          try {
            log(`Używanie Web Speech API. Tekst: "${SPEECH_TEXT}", język: ${SPEECH_LANG}`);
            await speakText(SPEECH_TEXT, SPEECH_LANG);
            setStatus("ok", "Sukces", `Odczytano "${SPEECH_TEXT}". Jeśli nic nie słyszysz, sprawdź głośność i tryb cichy.`);
            log(`Mówienie zakończone pomyślnie.`);
          } catch (err) {
            const msg = err && typeof err === "object" && "message" in err ? String(err.message) : String(err);
            setStatus(
              "bad",
              "Błąd",
              `Nie udało się odczytać tekstu. Zobacz szczegóły debugowania. Spróbuj: zwiększ głośność, wyłącz Bluetooth i kliknij ponownie.`
            );
            log(`Błąd mówienia: ${msg}`);
          }
        }

        function onResetClick() {
          // Cancel any ongoing speech
          if (window.speechSynthesis) {
            window.speechSynthesis.cancel();
          }
          currentUtterance = null;
          logEl.textContent = "";
          setStatus(
            "ready",
            "Gotowe",
            `Kliknij przycisk, aby usłyszeć "${SPEECH_TEXT}". Jeśli nic nie słyszysz, sprawdź głośność, tryb cichy i połączenie Bluetooth.`
          );
          log("Reset kliknięty; status wyczyszczony.");
          updateSpeechState();
        }

        // Initial info
        log(`User agent: ${navigator.userAgent}`);
        log(`HTTPS: ${location.protocol === "https:" ? "tak" : "nie"}; origin=${location.origin}`);
        
        const support = checkSpeechSupport();
        if (support.supported) {
          log(`Web Speech API jest obsługiwane.`);
          const synth = window.speechSynthesis;
          const voices = synth.getVoices();
          log(`Dostępne głosy: ${voices.length}`);
          const polishVoices = voices.filter(v => v.lang.startsWith("pl"));
          if (polishVoices.length > 0) {
            log(`Głosy polskie: ${polishVoices.map(v => `${v.name} (${v.lang})`).join(", ")}`);
          } else {
            log(`Uwaga: nie znaleziono głosów polskich. Używany będzie domyślny głos.`);
          }
        } else {
          log(`Błąd: ${support.error}`);
        }
        
        updateSpeechState();
        setStatus("ready", "Gotowe", `Kliknij przycisk, aby usłyszeć "${SPEECH_TEXT}".`);
        
        // Some browsers load voices asynchronously
        if (window.speechSynthesis && window.speechSynthesis.onvoiceschanged !== undefined) {
          window.speechSynthesis.onvoiceschanged = () => {
            const voices = window.speechSynthesis.getVoices();
            const polishVoices = voices.filter(v => v.lang.startsWith("pl"));
            if (polishVoices.length > 0) {
              log(`Głosy załadowane: ${polishVoices.map(v => `${v.name} (${v.lang})`).join(", ")}`);
            }
          };
        }

        playBtn.addEventListener("click", async () => {
          // Enforce "only after interaction": everything audio-related happens inside this handler.
          const start = Date.now();
          try {
            await onPlayClick();
          } finally {
            // If user clicks repeatedly, re-enable quickly but avoid double-press spam.
            const elapsed = Date.now() - start;
            const minDisableMs = 450;
            const wait = Math.max(0, minDisableMs - elapsed);
            setTimeout(() => {
              if (lastPlayAt === start) playBtn.disabled = false;
            }, wait);
          }
        }, { passive: true });

        resetBtn.addEventListener("click", onResetClick, { passive: true });
      })();
    </script>
  </body>
</html>
